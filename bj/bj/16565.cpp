/*
bj16565 N포커

52매의 트럼프 카드에서 N장의 카드를 뽑는다.
뽑은 카드 중 "포카드" 족보가 있으면 이긴다.
이런 경우의 수를 구하라.

접근: 포함-배제 원리

1. 포함-배제 원리 적용
1을 포카드로 가지는 경우의 수 = C(48, N-4)
2을 포카드로 가지는 경우의 수 = C(48, N-4)
...
-> 총합 C(48, N-4) * C(13, 1) = S_1
1과 2를 포카드로 가지는 경우의 수 = C(44, N-8)
...
-> 총합 C(44, N-8) * C(13, 2) = S_2
...
-> S_n = C(52-4n, N-4n) * C(13, n).

포함-배제 원리에 따라 답은 다음과 같다.
S_1 - S_2 + S_3 - S_4 + ... -> S_n이 0이 될 때까지.

2. 조합의 DP 계산
조합에 대해 다음이 성립한다.
C(n, r) = C(n-1, r) + C(n-1, r-1)
C(n, 0) = 1
C(n, 1) = n
C(n, n) = 1
이는 간단하게 설명 가능한데, 예를 들어 5개중 3개를 조합한다 하자.
5개중 임의의 한 개를 고르고, 다음과 같이 경우를 나눈다.
1. 그 한 개를 사용해 조합하는 경우의 수 = C(4,2)
2. 그 한 개를 사용하지 않고 조합하는 경우의 수 = C(4,3)
따라서 C(5,3) = C(4,3) + C(4,2)이다.
이를 기반으로 2차원 DP를 먼저 한 다음 1번을 계산하면 된다.

3. 미리 계산
입력의 경우의 수가 적으므로 0부터 52까지의 입력에 대해 모두 미리 계산할 수도
있다. 그 값은 다음과 같다. constexpr std::array<int, 53> results = { 0, 0, 0, 0,
13, 624, 4657, 4694, 7698, 952, 4330, 6075, 4566, 7393, 9798, 2532, 1668, 5707,
6494, 1451, 5610, 360, 9054, 7264, 6421, 735, 7912, 8538, 1577, 5488, 3779,
3700, 8588, 6127, 7780, 5472, 789, 1634, 6898, 9133, 2342, 5811, 7955, 1850,
1743, 977, 4282, 7147, 536, 2086, 1326, 52, 1
};

*/

#include <array>
#include <iostream>

constexpr int MOD = 10'007;

int main(void) {
  std::array<std::array<int, 53>, 53> DP{};

  // DP[r][n] == C(n, r)
  // base case
  for (int n = 0; n <= 52; ++n) {
    DP[0][n] = 1;
  }
  for (int r = 1; r <= 52; ++r) {
    for (int n = r; n <= 52; ++n) {
      DP[r][n] = DP[r][n - 1] + DP[r - 1][n - 1];
      DP[r][n] %= MOD;
    }
  }

  // solve
  int n;
  std::cin >> n;

  int total_cards = 52;
  int result = 0;
  int sign = 1;
  int num_of_4cards = 1;
  while ((n - 4 * num_of_4cards) >= 0) {
    result += sign * DP[num_of_4cards][13] *
              DP[n - 4 * num_of_4cards][total_cards - 4 * num_of_4cards];
    result %= MOD;
    sign *= -1;
    num_of_4cards += 1;
  }
  if (result < 0) result += MOD;

  std::cout << result << '\n';

  return 0;
}
